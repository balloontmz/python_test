来自https://www.cnblogs.com/feixuelove1009/p/6143539.html
##一、排序的基本概念和分类
所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。

排序的稳定性：
经过某种排序后，如果两个记录序号同等，且两者在原无序记录中的先后秩序依然保持不变，则称所使用的排序方法是稳定的，反之是不稳定的。

内排序和外排序
内排序：排序过程中，待排序的所有记录全部放在内存中
外排序：排序过程中，使用到了外部存储。
通常讨论的都是内排序。

影响内排序算法性能的三个因素：

时间复杂度：即时间性能，高效率的排序算法应该是具有尽可能少的关键字比较次数和记录的移动次数
空间复杂度：主要是执行算法所需要的辅助空间，越少越好。
算法复杂性。主要是指代码的复杂性。
根据排序过程中借助的主要操作，可把内排序分为：

插入排序
交换排序
选择排序
归并排序
按照算法复杂度可分为两类：

简单算法：包括冒泡排序、简单选择排序和直接插入排序
改进算法：包括希尔排序、堆排序、归并排序和快速排序
以下的七种排序算法只是所有排序算法中最经典的几种，不代表全部。
冒泡排序 -> 快速排序
简单选择排序 -> 堆排序
直接插入买需 -> 希尔排序

## 快速排序
1.快速排序的时间性能取决于递归的深度
2.当pivot_key恰好处于记录关键码的中间值时，大小两区的划分比较均衡，接近一个平衡二叉树，
此时的时间复杂度为o(nlog(n))
3.当原记录集合是一个正序或者逆序的情况下，分区的结果就是一颗斜树，其深度为n-1,每一次执行
大小分区，都要使用n-i此比较，其最终时间复杂度为o(n^2)
4.在一般情况下，通过数学归纳法可证明，快速排序的时间复杂度为o(nlog(n))
5.但是由于关键字的比较和交换是跳跃式的，因此，快速排序是一种不稳定排序。
6.同时由于采用的递归技术，该算法需要一定的辅助空间，其空间复杂度o(logn)

some notes
1.数据过万，冒泡算法基本不可用。测试时间忠实的反映了n平方的时间复杂度，数据扩大10倍，耗时增加100倍
2.对于Python的列表，反序遍历比正序遍历还是要消耗一定的时间的
3.快速排序在数据较大时，其威力显现，但不够稳定，总体还是维护了nlog(n)的复杂度。